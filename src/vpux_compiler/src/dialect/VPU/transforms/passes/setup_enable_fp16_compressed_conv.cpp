//
// Copyright (C) 2024 Intel Corporation.
// SPDX-License-Identifier: Apache 2.0
//

#include "vpux/compiler/dialect/IE/IR/ops.hpp"
#include "vpux/compiler/dialect/VPU/transforms/passes.hpp"
#include "vpux/compiler/dialect/VPU/utils/compressed_convolution_utils.hpp"
#include "vpux/compiler/utils/analysis.hpp"
#include "vpux/utils/core/error.hpp"

using namespace vpux;

namespace {

//
// SetupEnableFP16CompressedConvPass
//

class SetupEnableFP16CompressedConvPass final :
        public VPU::SetupEnableFP16CompressedConvBase<SetupEnableFP16CompressedConvPass> {
public:
    SetupEnableFP16CompressedConvPass() = default;
    SetupEnableFP16CompressedConvPass(const VPU::InitCompilerOptions& initCompilerOptions, Logger log)
            : _enableFP16CompressedConvolution(enableFP16CompressedConvolution) {
        Base::initLogger(log, Base::getArgumentName());
        Base::copyOptionValuesFrom(initCompilerOptions);

        initializeFromOptions();
    }

private:
    mlir::LogicalResult initializeOptions(StringRef options) final;
    void safeRunOnModule() final;

private:
    // Initialize fields from pass options
    void initializeFromOptions();

private:
    bool _enableFP16CompressedConvolution = false;
    bool _allowCustomValues = false;
};

void addOption(mlir::OpBuilder optionsBuilder, IE::PipelineOptionsOp pipelineOptionsOp, mlir::StringRef optionName,
               size_t optionValue, bool allowCustomValues) {
    auto hasPipelineOption = pipelineOptionsOp.lookupSymbol<IE::OptionOp>(optionName) != nullptr;
    VPUX_THROW_WHEN(!allowCustomValues && hasPipelineOption,
                    "FP16 Compressed Conv is already defined, probably you run '--init-compiler' twice");

    if (hasPipelineOption) {
        return;
    }
    auto* ctx = optionsBuilder.getContext();
    const auto constraintAttr = mlir::StringAttr::get(ctx, optionName);
    optionsBuilder.create<IE::OptionOp>(optionsBuilder.getUnknownLoc(), constraintAttr,
                                        mlir::BoolAttr::get(ctx, optionValue));
}

mlir::LogicalResult SetupEnableFP16CompressedConvPass::initializeOptions(StringRef options) {
    if (mlir::failed(Base::initializeOptions(options))) {
        return mlir::failure();
    }

    initializeFromOptions();

    return mlir::success();
}

void SetupEnableFP16CompressedConvPass::initializeFromOptions() {
    if (enableFP16CompressedConvolution.hasValue()) {
        _log.trace("Overloading the default value {0} of the '_enableFP16CompressedConvolution' field to the value {1} "
                   "of the pass option 'enableFP16CompressedConvolution' generated by MLIR",
                   _enableFP16CompressedConvolution, enableFP16CompressedConvolution);
        _enableFP16CompressedConvolution = enableFP16CompressedConvolution;
    }

    if (allowCustomValues.hasValue()) {
        _allowCustomValues = allowCustomValues.getValue();
    }
}

void SetupEnableFP16CompressedConvPass::safeRunOnModule() {
    auto moduleOp = getModuleOp(getOperation());
    auto optionsBuilder = mlir::OpBuilder::atBlockBegin(moduleOp.getBody());
    auto pipelineOptionsOp = VPU::getPipelineOptionsOp(getContext(), moduleOp);
    optionsBuilder =
            mlir::OpBuilder::atBlockBegin(&pipelineOptionsOp.getOptions().front(), optionsBuilder.getListener());

    addOption(optionsBuilder, pipelineOptionsOp, VPU::FP16_COMPRESSED_CONV, _enableFP16CompressedConvolution,
              _allowCustomValues);
}

}  // namespace

//
// createSetupEnableFP16CompressedConvPass
//

std::unique_ptr<mlir::Pass> vpux::VPU::createSetupEnableFP16CompressedConvPass() {
    return std::make_unique<SetupEnableFP16CompressedConvPass>();
}

std::unique_ptr<mlir::Pass> vpux::VPU::createSetupEnableFP16CompressedConvPass(
        const VPU::InitCompilerOptions& initCompilerOptions, Logger log) {
    return std::make_unique<SetupEnableFP16CompressedConvPass>(initCompilerOptions, log);
}
