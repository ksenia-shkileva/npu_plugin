//
// Copyright (C) 2024 Intel Corporation.
// SPDX-License-Identifier: Apache 2.0
//

#include "vpux/compiler/dialect/IE/IR/ops.hpp"
#include "vpux/compiler/dialect/VPU/transforms/passes.hpp"
#include "vpux/compiler/dialect/VPU/utils/nce_reduce_utils.hpp"
#include "vpux/compiler/utils/analysis.hpp"
#include "vpux/utils/core/error.hpp"

using namespace vpux;

namespace {

//
// SetupIsReduceSupportedPass
//

class SetupIsReduceSupportedPass final : public VPU::SetupIsReduceSupportedBase<SetupIsReduceSupportedPass> {
public:
    SetupIsReduceSupportedPass() = default;
    SetupIsReduceSupportedPass(const VPU::InitCompilerOptions& initCompilerOptions, Logger log)
            : _enableIsReduceSupported(enableIsReduceSupported) {
        Base::initLogger(log, Base::getArgumentName());
        Base::copyOptionValuesFrom(initCompilerOptions);

        initializeFromOptions();
    }

private:
    mlir::LogicalResult initializeOptions(StringRef options) final;
    void safeRunOnModule() final;

private:
    // Initialize fields from pass options
    void initializeFromOptions();

private:
    bool _enableIsReduceSupported = false;
    bool _allowCustomValues = false;
};

void addOption(mlir::OpBuilder optionsBuilder, IE::PipelineOptionsOp pipelineOptionsOp, mlir::StringRef optionName,
               size_t optionValue, bool allowCustomValues) {
    auto hasPipelineOption = pipelineOptionsOp.lookupSymbol<IE::OptionOp>(optionName) != nullptr;
    VPUX_THROW_WHEN(!allowCustomValues && hasPipelineOption,
                    "IsReduceSupported is already defined, probably you run '--init-compiler' twice");

    if (hasPipelineOption) {
        return;
    }
    auto* ctx = optionsBuilder.getContext();
    const auto constraintAttr = mlir::StringAttr::get(ctx, optionName);
    optionsBuilder.create<IE::OptionOp>(optionsBuilder.getUnknownLoc(), constraintAttr,
                                        mlir::BoolAttr::get(ctx, optionValue));
}

mlir::LogicalResult SetupIsReduceSupportedPass::initializeOptions(StringRef options) {
    if (mlir::failed(Base::initializeOptions(options))) {
        return mlir::failure();
    }

    initializeFromOptions();

    return mlir::success();
}

void SetupIsReduceSupportedPass::initializeFromOptions() {
    if (enableIsReduceSupported.hasValue()) {
        _log.trace("Overloading the default value {0} of the '_enableIsReduceSupported' field to the value {1} "
                   "of the pass option 'enableIsReduceSupported' generated by MLIR",
                   _enableIsReduceSupported, enableIsReduceSupported);
        _enableIsReduceSupported = enableIsReduceSupported;
    }

    if (allowCustomValues.hasValue()) {
        _allowCustomValues = allowCustomValues.getValue();
    }
}

void SetupIsReduceSupportedPass::safeRunOnModule() {
    auto moduleOp = getModuleOp(getOperation());
    auto optionsBuilder = mlir::OpBuilder::atBlockBegin(moduleOp.getBody());
    auto pipelineOptionsOp = VPU::getPipelineOptionsOp(getContext(), moduleOp);
    optionsBuilder =
            mlir::OpBuilder::atBlockBegin(&pipelineOptionsOp.getOptions().front(), optionsBuilder.getListener());

    addOption(optionsBuilder, pipelineOptionsOp, VPU::REDUCE_SUPPORTED, _enableIsReduceSupported, _allowCustomValues);
}

}  // namespace

//
// createSetupIsReduceSupportedPass
//

std::unique_ptr<mlir::Pass> vpux::VPU::createSetupIsReduceSupportedPass() {
    return std::make_unique<SetupIsReduceSupportedPass>();
}

std::unique_ptr<mlir::Pass> vpux::VPU::createSetupIsReduceSupportedPass(
        const VPU::InitCompilerOptions& initCompilerOptions, Logger log) {
    return std::make_unique<SetupIsReduceSupportedPass>(initCompilerOptions, log);
}
