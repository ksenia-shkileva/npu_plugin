//
// Copyright (C) 2023-2024 Intel Corporation.
// SPDX-License-Identifier: Apache 2.0
//

#include "vpux/compiler/NPU40XX/dialect/NPUReg40XX/ops.hpp"
#include "vpux/compiler/NPU40XX/dialect/NPUReg40XX/types.hpp"
#include "vpux/compiler/NPU40XX/dialect/NPUReg40XX/utils.hpp"
#include "vpux/compiler/NPU40XX/dialect/VPUIPDPU/ops.hpp"
#include "vpux/compiler/conversion.hpp"
#include "vpux/compiler/dialect/VPUMI40XX/utils.hpp"
#include "vpux/compiler/dialect/VPURegMapped/types.hpp"
#include "vpux/compiler/dialect/VPURegMapped/utils.hpp"
#include "vpux/compiler/utils/ELF/utils.hpp"
#include "vpux/compiler/utils/compression_utils.hpp"
#include "vpux/utils/core/mem_size.hpp"

#include <npu_40xx_nnrt.hpp>

using namespace vpux;
using namespace vpux::VPURegMapped;
using namespace npu40xx;
using namespace NPUReg40XX;
using namespace NPUReg40XX::Descriptors;

namespace {

uint64_t getTensorMode(mlir::Type type) {
    if (auto quantized = mlir::dyn_cast<mlir::quant::QuantizedType>(type)) {
        return getTensorMode(quantized.getStorageType());
    }

    if (type.isSignedInteger() || type.isUnsignedInteger() || type.isSignlessInteger()) {
        return DMA_ACC_DTYPE_INT8_UINT8;
    } else {
        return DMA_ACC_DTYPE_FP16_BF16;
    }

    VPUX_THROW("Invalid tensor type for DMA Acceleration configuration {0}", type);
}

void setDMAConversionMode(DMARegister& initValues, mlir::Type inputType, uint64_t srcSize, mlir::Type outputType,
                          uint64_t dstSize) {
    uint64_t conversionCfg = 0;
    if (inputType != outputType) {
        if (inputType.isF32() && outputType.isF16()) {
            conversionCfg = DMA_DATA_CONV_FP32_FP16;
        } else if (inputType.isF32() && outputType.isBF16()) {
            conversionCfg = DMA_DATA_CONV_FP32_BF16;
        } else {
            VPUX_THROW("Unsupported DMA data conversion");
        }

        VPUX_THROW_WHEN(dstSize != (srcSize / 2), "Source and destination length do not match");
    }

    initValues.write<Fields::dma_cfg_fields_conversion_cfg>(conversionCfg);
}

uint32_t getActCompressionEntryTileMask(VPUASM::NNDMAOp dmaOp) {
    auto actCompressionSizeEntry = dmaOp.getActCompressionSizeEntry();
    if (actCompressionSizeEntry.has_value()) {
        auto actCompBufferRef = mlir::SymbolTable::lookupNearestSymbolFrom(dmaOp, actCompressionSizeEntry.value());
        VPUX_THROW_UNLESS(actCompBufferRef, "Could not find symbol name entry for {0} of {1}",
                          actCompressionSizeEntry.value(), dmaOp);

        if (mlir::isa<VPUASM::DeclareBufferOp>(actCompBufferRef)) {
            auto actCompBuffer = mlir::cast<VPUASM::DeclareBufferOp>(actCompBufferRef);
            return NPUReg40XX::getTileSelectMaskForBuffer(actCompBuffer);
        }
    }
    return 0;
}

void setDMAAccelerationCompress(DMARegister& initValues, VPUASM::NNDMAOp origOp, mlir::MemRefType inputType,
                                mlir::MemRefType outputType) {
    const auto dmaDescriptor = origOp.getDmaDescriptor();
    const auto srcWidth = dmaDescriptor.getSrcWidth().getInt();
    const auto dstWidth = outputType.cast<vpux::NDTypeInterface>().getTotalAllocSize().count();

    const auto uncompressedBufSize = inputType.cast<vpux::NDTypeInterface>().getTotalAllocSize().count();
    VPUX_THROW_UNLESS(uncompressedBufSize > ACT_COMPRESSION_MIN_BUF_SIZE,
                      "Uncompressed buffer size '{0}' needs to be larger then '{1}'", uncompressedBufSize,
                      ACT_COMPRESSION_MIN_BUF_SIZE);

    initValues.write<Fields::dma_width_src>(srcWidth);
    initValues.write<Fields::dma_width_dst>(dstWidth);

    if (origOp.getActCompressionSizeEntry().has_value()) {
        initValues.write<Fields::dma_cfg_fields_rws_en>(true);
        initValues.write<Fields::dma_remote_width_store>(getActCompressionEntryTileMask(origOp));
    }

    initValues.write<Fields::dma_cfg_fields_acceleration_cfg>(DMA_ACCEL_COMPRESS);
    initValues.write<Fields::dma_acc_info_compress_dtype>(getTensorMode(inputType.getElementType()));
    initValues.write<Fields::dma_acc_info_compress_bitc_en>(1);
}

void setDMAAccelerationDecompress(DMARegister& initValues, VPUASM::NNDMAOp origOp, mlir::MemRefType outputType) {
    auto actCompressionSizeEntry = origOp.getActCompressionSizeEntry();
    if (actCompressionSizeEntry.has_value()) {
        initValues.write<Fields::dma_cfg_fields_rwf_en>(true);
        initValues.write<Fields::dma_remote_width_fetch>(getActCompressionEntryTileMask(origOp));
    }

    initValues.write<Fields::dma_cfg_fields_acceleration_cfg>(DMA_ACCEL_DECOMPRESS);
    initValues.write<Fields::dma_acc_info_decompress_dtype>(getTensorMode(outputType.getElementType()));
    initValues.write<Fields::dma_acc_info_decompress_bitc_en>(1);
}

void setDMAAccelerationMode(DMARegister& initValues, VPUASM::NNDMAOp origOp, mlir::MemRefType inputType,
                            mlir::MemRefType outputType) {
    auto accMode = origOp.getAccelerationMode();
    switch (accMode) {
    case VPUIP::DMAAccMode::DISABLE:
        // nothing to do
        break;
    case VPUIP::DMAAccMode::COMPRESSION:
        setDMAAccelerationCompress(initValues, origOp, inputType, outputType);
        break;
    case VPUIP::DMAAccMode::DECOMPRESSION:
        setDMAAccelerationDecompress(initValues, origOp, outputType);
        break;
    default:
        VPUX_THROW("{0} acceleration mode is not supported", accMode);
        break;
    }
}

void setEnableMemorySideCaching(DMARegister& initValues) {
    initValues.write<Fields::dma_src_aub>(DMA_AUB_SRC_DST);
    initValues.write<Fields::dma_dst_aub>(DMA_AUB_SRC_DST);
    initValues.write<Fields::dma_cfg_fields_axi_user_bits_cfg>(DMA_AUB_SRC_DST);
}

struct NPUReg40XX_3D_DmaConfig {
    uint64_t srcWidth;
    uint64_t dstWidth;

    uint64_t srcDimSize1;
    uint64_t dstDimSize1;

    uint64_t srcStride1;
    uint64_t dstStride1;

    uint64_t srcDimSize2;
    uint64_t dstDimSize2;

    uint64_t srcStride2;
    uint64_t dstStride2;

    uint64_t numDims;
};

NPUReg40XX_3D_DmaConfig configure3DDma(VPUIP::DMADescriptorAttr vpu27Config) {
    NPUReg40XX_3D_DmaConfig vpu4config{};

    auto numPlanes = vpu27Config.getNumPlanes().getInt();
    auto length = vpu27Config.getLen().getInt();
    auto srcWidth = vpu27Config.getSrcWidth().getInt();
    auto srcStride = vpu27Config.getSrcStride().getInt();
    auto srcPlaneStride = vpu27Config.getSrcPlaneStride().getInt();
    auto dstWidth = vpu27Config.getDstWidth().getInt();
    auto dstStride = vpu27Config.getDstStride().getInt();
    auto dstPlaneStride = vpu27Config.getDstPlaneStride().getInt();

    auto srcDimSize1 = srcWidth ? static_cast<int64_t>((length / srcWidth) - 1) : 0;
    auto dstDimSize1 = (dstWidth && (length > dstWidth)) ? static_cast<int64_t>((length / dstWidth) - 1) : 0;

    int64_t numDims = 0;
    if (numPlanes > 1) {
        numDims = DMA_3D;
    } else if (srcWidth == srcStride && dstWidth == dstStride) {
        numDims = DMA_1D;
    } else {
        numDims = DMA_2D;
    }
    vpu4config.numDims = numDims;

    switch (numDims) {
    case DMA_3D:
        VPUX_THROW_WHEN(numPlanes == 0, "numPlanes cannot be 0 for a 3D transaction");
        vpu4config.srcDimSize2 = numPlanes - 1;
        vpu4config.dstDimSize2 = numPlanes - 1;

        vpu4config.srcStride2 = srcPlaneStride;
        vpu4config.dstStride2 = dstPlaneStride;

        [[fallthrough]];
    case DMA_2D:
        vpu4config.srcDimSize1 = srcDimSize1;
        vpu4config.dstDimSize1 = dstDimSize1;

        vpu4config.srcStride1 = srcStride;
        vpu4config.dstStride1 = dstStride;

        [[fallthrough]];
    case DMA_1D:
        vpu4config.srcWidth = srcWidth;
        vpu4config.dstWidth = dstWidth;
        break;
    default:
        VPUX_THROW("Error at configure3DDma. Unsupported numDims={0}", numDims);
        break;
    }

    return vpu4config;
}

class NNDMARewriter final : public mlir::OpRewritePattern<VPUASM::NNDMAOp> {
public:
    NNDMARewriter(mlir::MLIRContext* ctx, Logger log, ELF::SymbolReferenceMap& symRefMap)
            : mlir::OpRewritePattern<VPUASM::NNDMAOp>(ctx), _log(log), _symRefMap(symRefMap) {
        setDebugName("NNDMA_VPUASM2NPUReg40XXRewriter");
    }

public:
    mlir::LogicalResult matchAndRewrite(VPUASM::NNDMAOp origOp, mlir::PatternRewriter& rewriter) const final;

private:
    bool isWorkLoadManagementDMA(mlir::Operation* op) const {
        return mlir::isa<VPUASM::DPUInvariantOp, VPUASM::DPUVariantOp, VPUIPDPU::DPUInvariantOp, VPUIPDPU::DPUVariantOp,
                         VPUASM::ActKernelInvocationOp, VPUASM::ActKernelRangeOp, VPUASM::DeclareTaskBufferOp>(op);
    }

    Logger _log;
    ELF::SymbolReferenceMap& _symRefMap;
};

// Hardware supports Gather/Scatter mode, currently only Gather is supported by compiler.
void setGatherMode(ELF::SymbolReferenceMap& _symRefMap, const ::mlir::SymbolRefAttr& indices, DMARegister& initValues,
                   const mlir::MemRefType& outputType, Bit elemOutSize) {
    mlir::MemRefType indicesType;
    auto indicesBufferRep = _symRefMap.lookupSymbol(indices);
    if (mlir::isa<VPUASM::DeclareBufferOp>(indicesBufferRep)) {
        auto indicesBuffer = mlir::cast<VPUASM::DeclareBufferOp>(indicesBufferRep);
        indicesType = indicesBuffer.getBufferType().getMemref();
    }
    // DMA copies data block by block example here with
    // input 50257x768xf32 indices 1024xi64
    // output 1024x768xf32 so dma will copy 1024 blocks of 768xsizeof(f32) blocks so elementsize here would be 3072
    // We dont need axis info here as gather cant be done here if indices are pointing so leftmost dimension who has
    // size bigger than 1. There condition will be enforced on upper level dialects.
    const auto dma_element_size =
            (outputType.getNumElements() / indicesType.getNumElements()) * elemOutSize.to<Byte>().count();

    initValues.write<Fields::dma_cfg_fields_src_list_cfg>(DMA_LIST_REL_INDEX);
    initValues.write<Fields::dma_cfg_fields_dst_list_cfg>(0);
    initValues.write<Fields::dma_list_size_src>(indicesType.getNumElements());
    initValues.write<Fields::dma_stride_dst_1>(dma_element_size);
    initValues.write<Fields::dma_width_src>(dma_element_size);
    initValues.write<Fields::dma_dim_size_1_dst>(0);
}

mlir::LogicalResult NNDMARewriter::matchAndRewrite(VPUASM::NNDMAOp origOp, mlir::PatternRewriter& rewriter) const {
    _log.trace("[{0}] Got '{1}' at '{2}'", getDebugName(), origOp->getName(), origOp->getLoc());

    // VPUASM ops already contain information about input/output buffers in `dma_descriptor` field
    // we should use it instead of looking related memref's by sym names
    // TODO: E#73178
    auto inputBufferRef = _symRefMap.lookupSymbol(origOp.getInput());
    VPUX_THROW_UNLESS(inputBufferRef, "Could not find symbol name entry for {0} of {1}", origOp.getInput(), origOp);
    mlir::MemRefType inputType;

    uint32_t inputTileMask = 0;
    bool isDMAInputForWLMDMA = false;
    if (mlir::isa<VPUASM::DeclareBufferOp>(inputBufferRef)) {
        auto inputBuffer = mlir::cast<VPUASM::DeclareBufferOp>(inputBufferRef);
        inputType = inputBuffer.getBufferType().getMemref();
        inputTileMask = vpux::NPUReg40XX::getTileSelectMaskForBuffer(inputBuffer);
    } else if (mlir::isa<VPUASM::ConstBufferOp>(inputBufferRef)) {
        auto inputBuffer = mlir::cast<VPUASM::ConstBufferOp>(inputBufferRef);
        inputType = inputBuffer.getBufferType().getMemref();
    } else if (isWorkLoadManagementDMA(inputBufferRef)) {
        isDMAInputForWLMDMA = true;
    } else {
        VPUX_THROW("Could not find symbol name entry for {0}", origOp.getInput());
    }

    uint32_t broadcastTileMask = 0;
    if (origOp.getTileIndexes().has_value()) {
        for (auto buffIndex : parseIntArrayAttr<int64_t>(origOp.getTileIndexes().value())) {
            broadcastTileMask |=
                    1 << (buffIndex + NPUReg40XX::CMX_TILE_SELECT_OFFSET);  // Bits 21 to 26 are used for tile select
        }
    }

    const int barrierEn = 1;
    const int ord = !origOp.getIsOutOfOrder();

    uint32_t linkAddressTileMask = 0;
    if (origOp.getNextLink().has_value()) {
        auto nextDMARef = _symRefMap.lookupSymbol(origOp.getNextLink().value());

        auto nextDMATaskBuffer = mlir::dyn_cast<VPUASM::DeclareTaskBufferOp>(nextDMARef);
        if (nextDMATaskBuffer) {
            linkAddressTileMask = NPUReg40XX::getTileSelectMaskForBuffer(nextDMATaskBuffer);
        }
    }

    auto vpu4config = configure3DDma(origOp.getDmaDescriptor());

    DMARegister descriptor;
    descriptor.write<Fields::dma_cfg_fields_num_dim>(vpu4config.numDims);
    descriptor.write<Fields::dma_cfg_fields_barrier_en>(barrierEn);
    descriptor.write<Fields::dma_cfg_fields_atp_en>(1);
    descriptor.write<Fields::dma_cfg_fields_src_burst_length>(15);
    descriptor.write<Fields::dma_cfg_fields_dst_burst_length>(15);
    descriptor.write<Fields::dma_cfg_fields_arb_qos>(255);
    descriptor.write<Fields::dma_cfg_fields_ord>(ord);
    descriptor.write<Fields::dma_cfg_fields_hwp_id_en>(1);
    descriptor.write<Fields::dma_cfg_fields_hwp_id>(origOp.getDmaHwpId().value_or(0));
    descriptor.write<Fields::dma_dim_size_1_src>(vpu4config.srcDimSize1);
    descriptor.write<Fields::dma_dim_size_1_dst>(vpu4config.dstDimSize1);
    descriptor.write<Fields::dma_stride_src_1>(vpu4config.srcStride1);
    descriptor.write<Fields::dma_stride_dst_1>(vpu4config.dstStride1);
    descriptor.write<Fields::dma_dim_size_2_src>(vpu4config.srcDimSize2);
    descriptor.write<Fields::dma_dim_size_2_dst>(vpu4config.dstDimSize2);
    descriptor.write<Fields::dma_stride_src_2>(vpu4config.srcStride2);
    descriptor.write<Fields::dma_src>(inputTileMask);
    descriptor.write<Fields::dma_dst>(broadcastTileMask);
    descriptor.write<Fields::dma_barrier_prod_mask_lower>(vpux::VPUMI40XX::computeMaskLo(origOp.getUpdateBarriers()));
    descriptor.write<Fields::dma_barrier_cons_mask_lower>(vpux::VPUMI40XX::computeMaskLo(origOp.getWaitBarriers()));
    descriptor.write<Fields::dma_barrier_prod_mask_upper>(vpux::VPUMI40XX::computeMaskHi(origOp.getUpdateBarriers()));
    descriptor.write<Fields::dma_barrier_cons_mask_upper>(vpux::VPUMI40XX::computeMaskHi(origOp.getWaitBarriers()));
    descriptor.write<Fields::dma_link_address>(linkAddressTileMask);
    descriptor.write<Fields::start_after_>(origOp.getStartAfter());
    descriptor.write<Fields::clean_after_>(origOp.getCleanAfter());

    if (auto enableMemorySideCaching = origOp.getEnableMscAttr()) {
        setEnableMemorySideCaching(descriptor);
    }

    auto actCompFlag = origOp.getActCompressionSizeEntry().has_value();
    auto accMode = origOp.getAccelerationMode();
    if (!actCompFlag) {
        // dma_width register conflicts with remote_width_fetch and should not be programmed in case of decompression
        // In case of compression it should not be programmed because dstWidth requires adjustment for worst case size
        descriptor.write<Fields::dma_width_src>(vpu4config.srcWidth);
        descriptor.write<Fields::dma_width_dst>(vpu4config.dstWidth);
    }

    if (!actCompFlag || accMode != vpux::VPUIP::DMAAccMode::COMPRESSION) {
        // dma_stride_dst_2 register conflicts with remote_width_store and should not be programmed in case of
        // compression
        descriptor.write<Fields::dma_stride_dst_2>(vpu4config.dstStride2);
    }

    if (!isDMAInputForWLMDMA) {
        auto outputBufferSym = origOp.getOutputBuffs()[0].dyn_cast_or_null<mlir::SymbolRefAttr>();
        VPUX_THROW_UNLESS(outputBufferSym, "`output_buffs` attribute should contain SymbolRefAttr but it doesn't");

        auto outputBufferRef = _symRefMap.lookupSymbol(outputBufferSym);
        auto outputBuffer = mlir::dyn_cast_or_null<VPUASM::DeclareBufferOp>(outputBufferRef);
        VPUX_THROW_UNLESS(outputBuffer, "Could not find symbol name entry for {0}", outputBufferRef);
        auto outputType = outputBuffer.getBufferType().getMemref();

        const auto elemInSize = vpux::getElemTypeSize(inputType);
        const auto elemOutSize = vpux::getElemTypeSize(outputType);

        auto totalInSizeBits = alignMemSize(inputType.getNumElements() * elemInSize, Byte(1));
        auto totalOutSizeBits = alignMemSize(outputType.getNumElements() * elemOutSize, Byte(1));

        // DMA only does FP32 -> FP16/BF16 conversions,
        // Because of this, dstDimSize1 will always be half of the original value
        if (inputType.getElementType() != outputType.getElementType() && vpu4config.dstDimSize1) {
            long newDstDimSize1 = ((vpu4config.dstDimSize1 + 1) / 2) - 1;
            descriptor.write<Fields::dma_dim_size_1_dst>(newDstDimSize1);
        }

        if (accMode != vpux::VPUIP::DMAAccMode::DISABLE) {
            VPUX_THROW_WHEN(vpu4config.srcDimSize1 != 0 || vpu4config.dstDimSize1 != 0 || vpu4config.srcDimSize2 != 0 ||
                                    vpu4config.dstDimSize2 != 0 || vpu4config.srcStride2 != 0 ||
                                    vpu4config.dstStride2 != 0,
                            "Activation compression is supported only for 1D DMAs");
            setDMAAccelerationMode(descriptor, origOp, inputType, outputType);
        } else {
            // Convertion
            setDMAConversionMode(descriptor, inputType.getElementType(), totalInSizeBits.to<Byte>().count(),
                                 outputType.getElementType(), totalOutSizeBits.to<Byte>().count());
        }

        auto indices = origOp.getIndices();
        if (indices.has_value()) {
            setGatherMode(_symRefMap, indices.value(), descriptor, outputType, elemOutSize);
        }
    }

    auto regDMADescriptorAttr = DMARegisterAttr::get(rewriter.getContext(), std::move(descriptor));

    auto dma = rewriter.create<NPUReg40XX::NNDMAOp>(origOp->getLoc(), origOp.getSymNameAttr(), regDMADescriptorAttr,
                                                    origOp.getInputAttr(), origOp.getOutputBuffsAttr(),
                                                    origOp.getNextLinkAttr(), origOp.getActCompressionSizeEntryAttr(),
                                                    origOp.getIndicesAttr());

    // TODO: (E#114625) Remove once proper refactoring happened
    if (!origOp.getTaskLocationAttr()) {
        dma.getOperation()->setAttr("directLink", rewriter.getUnitAttr());
    }

    rewriter.eraseOp(origOp);

    return mlir::success();
}

using RegisterMap = std::map<std::string, std::map<std::string, vpux::VPURegMapped::RegFieldValue>>;

void setNormFactor(RegisterMap& initValues, ::mlir::ArrayAttr normFactor) {
    const auto getRawFP16 = [](auto val) {
        const auto valFP16 = vpux::type::float16(val);
        return valFP16.to_bits();
    };

    auto normArr = parseFPArrayAttr<double>(normFactor);
    VPUX_THROW_UNLESS(normArr.size() == MEDIA_MAX_NUM_PLANES * 4 /*MEDIA_MAX_NUM_NORM_FACT*/,
                      "Normalization array is invalid");

    auto normFact00 = checked_cast_reg<NPUReg40XX::RegField_NormFact0Type>(getRawFP16(normArr[0]));
    auto normFact01 = checked_cast_reg<NPUReg40XX::RegField_NormFact1Type>(getRawFP16(normArr[1]));
    auto normFact02 = checked_cast_reg<NPUReg40XX::RegField_NormFact2Type>(getRawFP16(normArr[2]));
    auto normFact03 = checked_cast_reg<NPUReg40XX::RegField_NormFact3Type>(getRawFP16(normArr[3]));

    auto normFact10 = checked_cast_reg<NPUReg40XX::RegField_NormFact0Type>(getRawFP16(normArr[4]));
    auto normFact11 = checked_cast_reg<NPUReg40XX::RegField_NormFact1Type>(getRawFP16(normArr[5]));
    auto normFact12 = checked_cast_reg<NPUReg40XX::RegField_NormFact2Type>(getRawFP16(normArr[6]));
    auto normFact13 = checked_cast_reg<NPUReg40XX::RegField_NormFact3Type>(getRawFP16(normArr[7]));

    auto normFact20 = checked_cast_reg<NPUReg40XX::RegField_NormFact0Type>(getRawFP16(normArr[8]));
    auto normFact21 = checked_cast_reg<NPUReg40XX::RegField_NormFact1Type>(getRawFP16(normArr[9]));
    auto normFact22 = checked_cast_reg<NPUReg40XX::RegField_NormFact2Type>(getRawFP16(normArr[10]));
    auto normFact23 = checked_cast_reg<NPUReg40XX::RegField_NormFact3Type>(getRawFP16(normArr[11]));

    VPURegMapped::updateRegMappedInitializationValues(initValues, {{"NormFactor_0",
                                                                    {{"NormFact0", normFact00},
                                                                     {"NormFact1", normFact01},
                                                                     {"NormFact2", normFact02},
                                                                     {"NormFact3", normFact03}}},
                                                                   {"NormFactor_1",
                                                                    {{"NormFact0", normFact10},
                                                                     {"NormFact1", normFact11},
                                                                     {"NormFact2", normFact12},
                                                                     {"NormFact3", normFact13}}},
                                                                   {"NormFactor_2",
                                                                    {{"NormFact0", normFact20},
                                                                     {"NormFact1", normFact21},
                                                                     {"NormFact2", normFact22},
                                                                     {"NormFact3", normFact23}}}});
}

uint8_t getBytesOfPackOfPixels(VPU::M2iColorFmt inFormat) {
    switch (inFormat) {
    case VPU::M2iColorFmt::PL_FP16_RGB:
    case VPU::M2iColorFmt::PL_FP16_YUV:
    case VPU::M2iColorFmt::SP_NV12_10:
    case VPU::M2iColorFmt::SP_P010:
        return 2;
    case VPU::M2iColorFmt::IL_RGB888:
        return 3;
    case VPU::M2iColorFmt::IL_RGB8888:
    case VPU::M2iColorFmt::IL_RGB30:
        return 4;
    default:
        return 1;
    };
}

void setMediaDimensions(VPUASM::DeclareBufferOp bufferOp, VPU::M2iColorFmt format, uint64_t& width, uint64_t& height) {
    auto elemShape = bufferOp.getBufferType().getMemref().cast<NDTypeInterface>().getShape();

    switch (format) {
    case VPU::M2iColorFmt::PL_YUV420_8:
    case VPU::M2iColorFmt::SP_NV12_8:  // dims[] = N(0),H(1),W(2),C(3)
        // H / 3 * 2 -- These YUV formats have a full sized Y plane, and weaved U,V values,
        // hence we need to extract the height of the Y plane from the concatenated height
        height = elemShape[Dims4D::Act::C] / 3 * 2;
        width = elemShape[Dims4D::Act::H];
        break;

    case VPU::M2iColorFmt::IL_RGB888:  // dims[] = N(0),H(1),W(2),C(3)
        height = elemShape[Dims4D::Act::C];
        width = elemShape[Dims4D::Act::H];
        break;

    case VPU::M2iColorFmt::PL_RGB24:     // dims[] = N(0),C(1),H(2),W(3)
    case VPU::M2iColorFmt::PL_FP16_RGB:  // dims[] = N(0),C(1),H(2),W(3)
        height = elemShape[Dims4D::Act::H];
        width = elemShape[Dims4D::Act::W];
        break;

    default:
        VPUX_THROW("{0} format is not supported", format);
        break;
    }
}

void setInSizeDescription(RegisterMap& initValues, VPU::M2iColorFmt inFormat, uint64_t width, uint64_t height,
                          uint64_t m2iIndex) {
    uint64_t inSize0_ls(0), PSOB_inPS(0), inSize1_width(0), inSize1_height(0);
    uint64_t inSize1_ls(0), inSize2_width(0), inSize2_height(0), inSize2_ls(0);

    auto inSize0_width = checked_cast_reg<NPUReg40XX::RegField_widthType>(width - 1);
    auto inSize0_height = checked_cast_reg<NPUReg40XX::RegField_heightType>(height - 1);

    auto inSize0_PID = checked_cast_reg<NPUReg40XX::RegField_pidType>(m2iIndex);

    switch (inFormat) {
    case VPU::M2iColorFmt::PL_RGB24:
    case VPU::M2iColorFmt::PL_YUV444_8:
        inSize0_ls = checked_cast_reg<NPUReg40XX::RegField_lsType>(width);
        PSOB_inPS = checked_cast_reg<NPUReg40XX::RegField_inPSType>(width * height);
        inSize1_width = checked_cast_reg<NPUReg40XX::RegField_widthType>(width - 1);
        inSize1_height = checked_cast_reg<NPUReg40XX::RegField_heightType>(height - 1);
        inSize1_ls = checked_cast_reg<NPUReg40XX::RegField_lsType>(width);
        inSize2_width = checked_cast_reg<NPUReg40XX::RegField_widthType>(width - 1);
        inSize2_height = checked_cast_reg<NPUReg40XX::RegField_heightType>(height - 1);
        inSize2_ls = checked_cast_reg<NPUReg40XX::RegField_lsType>(width);
        break;

    case VPU::M2iColorFmt::PL_FP16_RGB:
        inSize0_ls = checked_cast_reg<NPUReg40XX::RegField_lsType>(width * 2);
        PSOB_inPS = checked_cast_reg<NPUReg40XX::RegField_inPSType>(width * height * 2);
        inSize1_width = checked_cast_reg<NPUReg40XX::RegField_widthType>(width - 1);
        inSize1_height = checked_cast_reg<NPUReg40XX::RegField_heightType>(height - 1);
        inSize1_ls = checked_cast_reg<NPUReg40XX::RegField_lsType>(width * 2);
        inSize2_width = checked_cast_reg<NPUReg40XX::RegField_widthType>(width - 1);
        inSize2_height = checked_cast_reg<NPUReg40XX::RegField_heightType>(height - 1);
        inSize2_ls = checked_cast_reg<NPUReg40XX::RegField_lsType>(width * 2);
        break;

    case VPU::M2iColorFmt::PL_GRAY8:
        inSize0_ls = checked_cast_reg<NPUReg40XX::RegField_lsType>(width);
        PSOB_inPS = checked_cast_reg<NPUReg40XX::RegField_inPSType>(width * height);
        inSize1_width = checked_cast_reg<NPUReg40XX::RegField_widthType>(width - 1);
        inSize1_height = checked_cast_reg<NPUReg40XX::RegField_heightType>(height - 1);
        inSize1_ls = checked_cast_reg<NPUReg40XX::RegField_lsType>(width);
        inSize2_width = checked_cast_reg<NPUReg40XX::RegField_widthType>(width - 1);
        inSize2_height = checked_cast_reg<NPUReg40XX::RegField_heightType>(height - 1);
        inSize2_ls = checked_cast_reg<NPUReg40XX::RegField_lsType>(width);
        break;

    case VPU::M2iColorFmt::SP_NV12_8:
        inSize0_ls = checked_cast_reg<NPUReg40XX::RegField_lsType>(width);
        PSOB_inPS = checked_cast_reg<NPUReg40XX::RegField_inPSType>(width * height);
        inSize1_width = checked_cast_reg<NPUReg40XX::RegField_widthType>(width - 1);
        inSize1_height = checked_cast_reg<NPUReg40XX::RegField_heightType>(height / 2 - 1);
        inSize1_ls = checked_cast_reg<NPUReg40XX::RegField_lsType>(width);
        break;

    case VPU::M2iColorFmt::PL_YUV420_8:
        inSize0_ls = checked_cast_reg<NPUReg40XX::RegField_lsType>(width);
        PSOB_inPS = checked_cast_reg<NPUReg40XX::RegField_inPSType>(width * height);
        inSize1_width = checked_cast_reg<NPUReg40XX::RegField_widthType>(width / 2 - 1);
        inSize1_height = checked_cast_reg<NPUReg40XX::RegField_heightType>(height / 2 - 1);
        inSize1_ls = checked_cast_reg<NPUReg40XX::RegField_lsType>(width / 2);
        inSize2_width = checked_cast_reg<NPUReg40XX::RegField_widthType>(width / 2 - 1);
        inSize2_height = checked_cast_reg<NPUReg40XX::RegField_heightType>(height / 2 - 1);
        inSize2_ls = checked_cast_reg<NPUReg40XX::RegField_lsType>(width / 2);
        break;

    case VPU::M2iColorFmt::PL_YUV422_8:
        inSize0_ls = checked_cast_reg<NPUReg40XX::RegField_lsType>(width);
        PSOB_inPS = checked_cast_reg<NPUReg40XX::RegField_inPSType>(width * height);
        inSize1_width = checked_cast_reg<NPUReg40XX::RegField_widthType>(width / 2 - 1);
        inSize1_height = checked_cast_reg<NPUReg40XX::RegField_heightType>(height - 1);
        inSize1_ls = checked_cast_reg<NPUReg40XX::RegField_lsType>(width / 2);
        inSize2_width = checked_cast_reg<NPUReg40XX::RegField_widthType>(width / 2 - 1);
        inSize2_height = checked_cast_reg<NPUReg40XX::RegField_heightType>(height - 1);
        inSize2_ls = checked_cast_reg<NPUReg40XX::RegField_lsType>(width / 2);
        break;

    case VPU::M2iColorFmt::IL_RGB888:
        inSize0_ls = checked_cast_reg<NPUReg40XX::RegField_lsType>(width * 3);
        PSOB_inPS = checked_cast_reg<NPUReg40XX::RegField_inPSType>(width * height * 3);
        inSize1_width = checked_cast_reg<NPUReg40XX::RegField_widthType>(width - 1);
        inSize1_height = checked_cast_reg<NPUReg40XX::RegField_heightType>(height - 1);
        inSize1_ls = checked_cast_reg<NPUReg40XX::RegField_lsType>(width * 3);
        inSize2_width = checked_cast_reg<NPUReg40XX::RegField_widthType>(width - 1);
        inSize2_height = checked_cast_reg<NPUReg40XX::RegField_heightType>(height - 1);
        inSize2_ls = checked_cast_reg<NPUReg40XX::RegField_lsType>(width * 3);
        break;

    default:
        VPUX_THROW("invalid input format {0}", inFormat);
        break;
    }

    VPURegMapped::updateRegMappedInitializationValues(
            initValues,
            {{"inSize0",
              {{"ls", inSize0_ls}, {"width", inSize0_width}, {"height", inSize0_height}, {"pid", inSize0_PID}}},
             {"inSize1", {{"ls", inSize1_ls}, {"width", inSize1_width}, {"height", inSize1_height}}},
             {"inSize2", {{"ls", inSize2_ls}, {"width", inSize2_width}, {"height", inSize2_height}}},
             {"PSOB", {{"inPS", PSOB_inPS}}}});
}

void setOutDescription(RegisterMap& initValues, VPU::M2iColorFmt outFormat, uint64_t outWidth, uint64_t outHeight) {
    uint64_t outScale0_width(0), outScale0_height(0);
    uint64_t psSc0Y(0), psSc0UV(0), lsSc0Y(0), lsSc0UV(0);

    switch (outFormat) {
    case VPU::M2iColorFmt::PL_RGB24:
    case VPU::M2iColorFmt::PL_GRAY8:
        outScale0_width = checked_cast_reg<NPUReg40XX::RegField_outScale0_widthType>(outWidth - 1);
        outScale0_height = checked_cast_reg<NPUReg40XX::RegField_outScale0_heightType>(outHeight - 1);
        psSc0Y = checked_cast_reg<NPUReg40XX::RegField_psSc0YType>(outWidth * outHeight);
        lsSc0Y = checked_cast_reg<NPUReg40XX::RegField_lsSc0YType>(outWidth);
        break;

    case VPU::M2iColorFmt::PL_FP16_YUV:
    case VPU::M2iColorFmt::PL_FP16_RGB:
        outScale0_width = checked_cast_reg<NPUReg40XX::RegField_outScale0_widthType>(outWidth - 1);
        outScale0_height = checked_cast_reg<NPUReg40XX::RegField_outScale0_heightType>(outHeight - 1);
        psSc0Y = checked_cast_reg<NPUReg40XX::RegField_psSc0YType>(outWidth * outHeight * 2);
        lsSc0Y = checked_cast_reg<NPUReg40XX::RegField_lsSc0YType>(outWidth * 2);
        break;

    case VPU::M2iColorFmt::SP_NV12_8:
        outScale0_width = checked_cast_reg<NPUReg40XX::RegField_outScale0_widthType>(outWidth - 1);
        outScale0_height = checked_cast_reg<NPUReg40XX::RegField_outScale0_heightType>(outHeight - 1);
        psSc0Y = checked_cast_reg<NPUReg40XX::RegField_psSc0YType>(outWidth * outHeight);
        psSc0UV = checked_cast_reg<NPUReg40XX::RegField_psSc0UVType>(outWidth * outHeight / 2);
        lsSc0Y = checked_cast_reg<NPUReg40XX::RegField_lsSc0YType>(outWidth);
        lsSc0UV = checked_cast_reg<NPUReg40XX::RegField_lsSc0UVType>(outWidth);
        break;

    case VPU::M2iColorFmt::PL_YUV420_8:
        outScale0_width = checked_cast_reg<NPUReg40XX::RegField_outScale0_widthType>(outWidth - 1);
        outScale0_height = checked_cast_reg<NPUReg40XX::RegField_outScale0_heightType>(outHeight - 1);
        psSc0Y = checked_cast_reg<NPUReg40XX::RegField_psSc0YType>(outWidth * outHeight);
        psSc0UV = checked_cast_reg<NPUReg40XX::RegField_psSc0UVType>(outWidth * outHeight / 4);
        lsSc0Y = checked_cast_reg<NPUReg40XX::RegField_lsSc0YType>(outWidth);
        lsSc0UV = checked_cast_reg<NPUReg40XX::RegField_lsSc0UVType>(outWidth / 2);
        break;

    case VPU::M2iColorFmt::PL_YUV422_8:
        outScale0_width = checked_cast_reg<NPUReg40XX::RegField_outScale0_widthType>(outWidth - 1);
        outScale0_height = checked_cast_reg<NPUReg40XX::RegField_outScale0_heightType>(outHeight - 1);
        psSc0Y = checked_cast_reg<NPUReg40XX::RegField_psSc0YType>(outWidth * outHeight);
        psSc0UV = checked_cast_reg<NPUReg40XX::RegField_psSc0UVType>(outWidth * outHeight / 2);
        lsSc0Y = checked_cast_reg<NPUReg40XX::RegField_lsSc0YType>(outWidth);
        lsSc0UV = checked_cast_reg<NPUReg40XX::RegField_lsSc0UVType>(outWidth / 2);
        break;

    case VPU::M2iColorFmt::PL_YUV444_8:
        outScale0_width = checked_cast_reg<NPUReg40XX::RegField_outScale0_widthType>(outWidth - 1);
        outScale0_height = checked_cast_reg<NPUReg40XX::RegField_outScale0_heightType>(outHeight - 1);
        psSc0Y = checked_cast_reg<NPUReg40XX::RegField_psSc0YType>(outWidth * outHeight);
        psSc0UV = checked_cast_reg<NPUReg40XX::RegField_psSc0UVType>(outWidth * outHeight);
        lsSc0Y = checked_cast_reg<NPUReg40XX::RegField_lsSc0YType>(outWidth);
        lsSc0UV = checked_cast_reg<NPUReg40XX::RegField_lsSc0UVType>(outWidth);
        break;

    case VPU::M2iColorFmt::IL_RGB888:
        outScale0_width = checked_cast_reg<NPUReg40XX::RegField_outScale0_widthType>(outWidth - 1);
        outScale0_height = checked_cast_reg<NPUReg40XX::RegField_outScale0_heightType>(outHeight - 1);
        psSc0Y = checked_cast_reg<NPUReg40XX::RegField_psSc0YType>(outWidth * outHeight * 3);
        lsSc0Y = checked_cast_reg<NPUReg40XX::RegField_lsSc0YType>(outWidth * 3);
        break;

    default:
        VPUX_THROW("invalid output format {0}", outFormat);
        break;
    }

    VPURegMapped::updateRegMappedInitializationValues(
            initValues,
            {{"OutScaleSize", {{"outScale0_width", outScale0_width}, {"outScale0_height", outScale0_height}}},
             {"ScPSY", {{"psSc0Y", psSc0Y}}},
             {"ScPSUV", {{"psSc0UV", psSc0UV}}},
             {"OutLS", {{"lsSc0Y", lsSc0Y}, {"lsSc0UV", lsSc0UV}}}});
}

bool isCscRequired(VPU::M2iColorFmt inFormat, VPU::M2iColorFmt outFormat) {
    // Automatically switch CSC on when input format and output format are different
    // and they are found in a viable conversion list
    llvm::DenseMap<VPU::M2iColorFmt, llvm::DenseSet<VPU::M2iColorFmt>> supportedInOutFormatMap = {
            {VPU::M2iColorFmt::SP_NV12_8,
             {VPU::M2iColorFmt::PL_RGB24, VPU::M2iColorFmt::IL_RGB888, VPU::M2iColorFmt::PL_FP16_RGB}},
            {VPU::M2iColorFmt::PL_RGB24,
             {VPU::M2iColorFmt::SP_NV12_8, VPU::M2iColorFmt::PL_YUV444_8, VPU::M2iColorFmt::PL_YUV422_8,
              VPU::M2iColorFmt::PL_GRAY8, VPU::M2iColorFmt::PL_YUV420_8}},
            {VPU::M2iColorFmt::IL_RGB888, {VPU::M2iColorFmt::SP_NV12_8}},
            {VPU::M2iColorFmt::PL_YUV444_8, {VPU::M2iColorFmt::PL_RGB24}},
            {VPU::M2iColorFmt::PL_YUV422_8, {VPU::M2iColorFmt::PL_RGB24}},
            {VPU::M2iColorFmt::PL_YUV420_8,
             {VPU::M2iColorFmt::PL_RGB24, VPU::M2iColorFmt::IL_RGB888, VPU::M2iColorFmt::PL_FP16_RGB}}};

    return (supportedInOutFormatMap.find(inFormat) != supportedInOutFormatMap.end() &&
            supportedInOutFormatMap[inFormat].find(outFormat) != supportedInOutFormatMap[inFormat].end());
}

class M2IRewriter final : public mlir::OpRewritePattern<VPUASM::M2IOp> {
public:
    M2IRewriter(mlir::MLIRContext* ctx, Logger log, ELF::SymbolReferenceMap& symRefMap)
            : mlir::OpRewritePattern<VPUASM::M2IOp>(ctx), _log(log), _symRefMap(symRefMap) {
        setDebugName("M2I_VPUASM2NPUReg40XXRewriter");
    }

public:
    mlir::LogicalResult matchAndRewrite(VPUASM::M2IOp origOp, mlir::PatternRewriter& rewriter) const final;

private:
    Logger _log;
    ELF::SymbolReferenceMap& _symRefMap;
};

mlir::LogicalResult M2IRewriter::matchAndRewrite(VPUASM::M2IOp origOp, mlir::PatternRewriter& rewriter) const {
    _log.trace("[{0}] Got '{1}' at '{2}'", getDebugName(), origOp->getName(), origOp->getLoc());

    // prepare MediaRegister
    auto initValues = NPUReg40XX::RegMapped_VpuMediaTaskType::getResetInitilizationValues();

    auto inFormat = checked_cast_reg<NPUReg40XX::RegField_inFormatType>(origOp.getInFmt());
    auto outFormat = checked_cast_reg<NPUReg40XX::RegField_outFormatType>(origOp.getOutFmt());
    auto sampleType = checked_cast_reg<NPUReg40XX::RegField_sampleTypeType>(origOp.getInterp());

    const auto chromaInRC = static_cast<uint64_t>(origOp.getChromaInReverseChannels());
    const auto lumaInRC = static_cast<uint64_t>(origOp.getLumaInReverseChannels());
    auto ifc = checked_cast_reg<NPUReg40XX::RegField_IFCType>(((chromaInRC & 0x1) << 5) | ((lumaInRC & 0x1) << 4) |
                                                              (getBytesOfPackOfPixels(origOp.getInFmt()) & 0xF));
    uint64_t irqMask = 1 << 15;
    irqMask = checked_cast_reg<NPUReg40XX::RegField_IRQMaskType>(irqMask);

    auto hScOffset = checked_cast_reg<NPUReg40XX::RegField_hSc_offsetType>(origOp.getTileOffsetX().value_or(0));
    auto hScFactor = checked_cast_reg<NPUReg40XX::RegField_hSc_factorType>(origOp.getScaleFactorX());
    auto vScOffset = checked_cast_reg<NPUReg40XX::RegField_hSc_offsetType>(origOp.getTileOffsetY().value_or(0));
    auto vScFactor = checked_cast_reg<NPUReg40XX::RegField_hSc_factorType>(origOp.getScaleFactorY());

    const auto chromaOutRC = static_cast<uint64_t>(origOp.getChromaOutReverseChannels());
    const auto lumaOutRC = static_cast<uint64_t>(origOp.getLumaOutReverseChannels());
    auto ofc = checked_cast_reg<NPUReg40XX::RegField_OFCType>(((chromaOutRC & 0x1) << 1) | (lumaOutRC & 0x1));

    uint64_t nextDescTileMask = 0;
    if (origOp.getNextLink().has_value()) {
        auto nextM2IRef = _symRefMap.lookupSymbol(origOp.getNextLink().value());
        if (auto nextM2ITaskBuffer = mlir::dyn_cast<VPUASM::DeclareTaskBufferOp>(nextM2IRef)) {
            nextDescTileMask = NPUReg40XX::getTileSelectMaskForBuffer(nextM2ITaskBuffer);
        }
    }

    uint64_t width(0), height(0), inputTileMask(0);
    auto m2iIndex = origOp.getTaskIndex().getValue();
    auto inBufferRef = _symRefMap.lookupSymbol(origOp.getInput());
    auto inBufferOp = mlir::dyn_cast_or_null<VPUASM::DeclareBufferOp>(inBufferRef);
    VPUX_THROW_UNLESS(inBufferOp, "Could not find symbol name entry for {0}", inBufferRef);
    inputTileMask = NPUReg40XX::getTileSelectMaskForBuffer(inBufferOp);
    setMediaDimensions(inBufferOp, origOp.getInFmt(), width, height);
    setInSizeDescription(initValues, origOp.getInFmt(), width, height, m2iIndex);
    auto roiWidth = checked_cast_reg<NPUReg40XX::RegField_roiWidthType>(width - 1);
    auto roiHeight = checked_cast_reg<NPUReg40XX::RegField_roiHeightType>(height - 1);

    uint64_t outWidth(0), outHeight(0), outputTileMask(0);
    auto outBufferRef = _symRefMap.lookupSymbol(origOp.getOutputBuff());
    auto outBufferOp = mlir::dyn_cast_or_null<VPUASM::DeclareBufferOp>(outBufferRef);
    VPUX_THROW_UNLESS(outBufferOp, "Could not find symbol name entry for {0}", outBufferRef);
    outputTileMask = NPUReg40XX::getTileSelectMaskForBuffer(outBufferOp);
    setMediaDimensions(outBufferOp, origOp.getOutFmt(), outWidth, outHeight);
    setOutDescription(initValues, origOp.getOutFmt(), outWidth, outHeight);
    outWidth = checked_cast_reg<NPUReg40XX::RegField_outScale0_widthType>(outWidth - 1);
    outHeight = checked_cast_reg<NPUReg40XX::RegField_outScale0_heightType>(outHeight - 1);

    if (origOp.getNorm().has_value()) {
        setNormFactor(initValues, origOp.getNorm().value());
    }

    auto startAfter = checked_cast_reg<NPUReg40XX::RegField_start_after_Type>(origOp.getStartAfter());
    auto cleanAfter = checked_cast_reg<NPUReg40XX::RegField_clean_after_Type>(origOp.getCleanAfter());

    auto barGateMaskLO = checked_cast_reg<NPUReg40XX::RegField_barGateMaskLOType>(
            VPUMI40XX::computeMaskLo(origOp.getWaitBarriers()));
    auto barGateMaskHI = checked_cast_reg<NPUReg40XX::RegField_barGateMaskHIType>(
            VPUMI40XX::computeMaskHi(origOp.getWaitBarriers()));
    auto updateLO = checked_cast_reg<NPUReg40XX::RegField_barUpdateLOType>(
            VPUMI40XX::computeMaskLo(origOp.getUpdateBarriers()));
    auto updatekHi = checked_cast_reg<NPUReg40XX::RegField_barUpdateHIType>(
            VPUMI40XX::computeMaskHi(origOp.getUpdateBarriers()));

    outFormat = checked_cast_reg<NPUReg40XX::RegField_outFormatLocalType>(outFormat);
    sampleType = checked_cast_reg<NPUReg40XX::RegField_samlingTypeLocalType>(sampleType);

    uint64_t operations(0);
    operations |= origOp.getDoCsc() ? (1 << 0) : 0;
    operations |= isCscRequired(origOp.getInFmt(), origOp.getOutFmt()) ? (1 << 3 | 1 << 0) : 0;  // CLAMP bit always set
    operations |= origOp.getDoNorm() ? 1 << 1 : 0;
    operations = checked_cast_reg<NPUReg40XX::RegField_operationsType>(operations);

    VPURegMapped::updateRegMappedInitializationValues(
            initValues, {
                                {"inAddr0", {{"inAddr", inputTileMask}}},
                                {"inAddr1", {{"inAddr", inputTileMask}}},
                                {"inAddr2", {{"inAddr", inputTileMask}}},
                                {"IOCfg",
                                 {{"inFormat", inFormat},
                                  {"outFormat", outFormat},
                                  {"sampleType", sampleType},
                                  {"numRois", 1},
                                  {"IFC", ifc},
                                  {"IRQMask", irqMask},
                                  {"operations", operations}}},
                                {"RoiDef",
                                 {{"roiBase", outputTileMask},
                                  {"OFC", ofc},
                                  {"outFormatLocal", outFormat},
                                  {"samlingTypeLocal", sampleType}}},
                                {"OutScaleSize", {{"outScale0_width", outWidth}, {"outScale0_height", outHeight}}},
                                {"RoiCfg", {{"roiWidth", roiWidth}, {"roiHeight", roiHeight}}},
                                {"ScOffset", {{"vSc_offset", vScOffset}, {"hSc_offset", hScOffset}}},
                                {"ScFactor", {{"vSc_factor", vScFactor}, {"hSc_factor", hScFactor}}},
                                {"nextDesc", {{"nextDesc", nextDescTileMask}}},
                                {"barGateMaskLO", {{"barGateMaskLO", barGateMaskLO}}},
                                {"barGateMaskHI", {{"barGateMaskHI", barGateMaskHI}}},
                                {"barUpdateLO", {{"barUpdateLO", updateLO}}},
                                {"barUpdateHI", {{"barUpdateHI", updatekHi}}},
                                {"media_barriers_sched_", {{"start_after_", startAfter}, {"clean_after_", cleanAfter}}},
                        });

    auto regM2IDescriptorAttr =
            VPURegMapped::getRegMappedAttributeWithValues<NPUReg40XX::RegMapped_VpuMediaTaskType>(rewriter, initValues);

    rewriter.create<NPUReg40XX::M2IOp>(origOp->getLoc(), origOp.getSymNameAttr(), origOp.getInputAttr(),
                                       origOp.getOutputBuffAttr(), origOp.getProfilingDataAttr(),
                                       origOp.getNextLinkAttr(), regM2IDescriptorAttr);

    rewriter.eraseOp(origOp);

    return mlir::success();
}

//
// ActShave
//

class ActShaveRtRewriter final : public mlir::OpRewritePattern<VPUASM::ActShaveRtOp> {
public:
    ActShaveRtRewriter(mlir::MLIRContext* ctx, Logger log)
            : mlir::OpRewritePattern<VPUASM::ActShaveRtOp>(ctx), _log(log) {
        setDebugName("ActShaveRt_VPUASM2NPUReg40XXRewriter");
    }

public:
    mlir::LogicalResult matchAndRewrite(VPUASM::ActShaveRtOp origOp, mlir::PatternRewriter& rewriter) const final;

private:
    Logger _log;
};

mlir::LogicalResult ActShaveRtRewriter::matchAndRewrite(VPUASM::ActShaveRtOp origOp,
                                                        mlir::PatternRewriter& rewriter) const {
    _log.trace("[{0}] Got '{1}' at '{2}'", getDebugName(), origOp->getName(), origOp->getLoc());

    rewriter.create<NPUReg40XX::ActShaveRtOp>(origOp->getLoc(), origOp.getSymNameAttr(), origOp.getKernelPathAttr());
    rewriter.eraseOp(origOp);
    return mlir::success();
}

//
// ActKernelRange
//
class ActKernelRangeRewriter final : public mlir::OpRewritePattern<VPUASM::ActKernelRangeOp> {
public:
    ActKernelRangeRewriter(mlir::MLIRContext* ctx, Logger log, ELF::SymbolReferenceMap& symRefMap)
            : mlir::OpRewritePattern<VPUASM::ActKernelRangeOp>(ctx), _log(log), _symRefMap(symRefMap) {
        setDebugName("ActKernelRange_VPUASM2NPUReg40XXRewriter");
    }

public:
    mlir::LogicalResult matchAndRewrite(VPUASM::ActKernelRangeOp origOp, mlir::PatternRewriter& rewriter) const final;

private:
    Logger _log;
    ELF::SymbolReferenceMap& _symRefMap;
};

mlir::LogicalResult ActKernelRangeRewriter::matchAndRewrite(VPUASM::ActKernelRangeOp origOp,
                                                            mlir::PatternRewriter& rewriter) const {
    _log.trace("[{0}] Got '{1}' at '{2}'", getDebugName(), origOp->getName(), origOp->getLoc());

    auto kernelEntry = NPUReg40XX::getKernelEntry(_symRefMap, origOp.getKernelEntry());
    auto kernelTextSize = NPUReg40XX::getKernelTextSize(_symRefMap, origOp.getKernelText());
    auto kernelTaskType = origOp.getKernelTaskType();
    auto kernelPath = NPUReg40XX::getKernelPath(_symRefMap, origOp.getKernelEntry(), kernelTaskType);
    auto actWLtype = static_cast<std::underlying_type<npu40xx::nn_public::VpuActWLType>::type>(
            NPUReg40XX::getActWLType(kernelTaskType));

    auto regActKernelDescriptorAttr =
            vpux::VPURegMapped::getRegMappedAttributeWithValues<vpux::NPUReg40XX::RegMapped_VpuActKernelRangeType>(
                    rewriter, {{"type", {{"type", actWLtype}}},
                               {"kernel_entry", {{"kernel_entry", kernelEntry}}},
                               {"code_size", {{"code_size", kernelTextSize}}}});

    rewriter.create<NPUReg40XX::ActKernelRangeOp>(origOp->getLoc(), origOp.getSymNameAttr(), regActKernelDescriptorAttr,
                                                  origOp.getTaskLocationAttr(), origOp.getKernelTextAttr(),
                                                  origOp.getKernelEntryAttr());

    _log.trace("[{0}] Got kernel '{1}' and cpu '{2}'", getDebugName(), kernelPath, VPU::getArch(origOp));

    rewriter.eraseOp(origOp);

    return mlir::success();
}

//
// ActKernelInvocation
//
class ActKernelInvocationRewriter final : public mlir::OpRewritePattern<VPUASM::ActKernelInvocationOp> {
public:
    ActKernelInvocationRewriter(mlir::MLIRContext* ctx, Logger log, ELF::SymbolReferenceMap& symRefMap)
            : mlir::OpRewritePattern<VPUASM::ActKernelInvocationOp>(ctx), _log(log), _symRefMap(symRefMap) {
        setDebugName("ActKernelInvocation_VPUASM2NPUReg40XXRewriter");
    }

public:
    mlir::LogicalResult matchAndRewrite(VPUASM::ActKernelInvocationOp origOp,
                                        mlir::PatternRewriter& rewriter) const final;

private:
    Logger _log;
    ELF::SymbolReferenceMap& _symRefMap;
};

mlir::LogicalResult ActKernelInvocationRewriter::matchAndRewrite(VPUASM::ActKernelInvocationOp origOp,
                                                                 mlir::PatternRewriter& rewriter) const {
    _log.trace("[{0}] Got '{1}' at '{2}'", getDebugName(), origOp->getName(), origOp->getLoc());

    auto kernelRangeRef = _symRefMap.lookupSymbol(origOp.getKernelRange());
    auto kernelRangeTaskBufferOp = mlir::cast<VPUASM::DeclareTaskBufferOp>(kernelRangeRef);
    auto kernelRangeTileMask = NPUReg40XX::getTileSelectMaskForBuffer(kernelRangeTaskBufferOp);
    auto kernelRangeIndex = origOp.getRangeIndex();

    uint64_t perfPacketTileMask = 0;
    if (auto profilingDataOpt = origOp.getProfilingData()) {
        auto perfPacketBufferRef = _symRefMap.lookupSymbol(*profilingDataOpt);
        auto perfPacketBufferOp = mlir::cast<VPUASM::DeclareBufferOp>(perfPacketBufferRef);
        perfPacketTileMask = NPUReg40XX::getTileSelectMaskForBuffer(perfPacketBufferOp);
    }

    auto waitMaskHi = VPUMI40XX::computeMaskHi(origOp.getWaitBarriers());
    auto waitMaskLo = VPUMI40XX::computeMaskLo(origOp.getWaitBarriers());
    auto postMaskHi = VPUMI40XX::computeMaskHi(origOp.getUpdateBarriers());
    auto postMaskLo = VPUMI40XX::computeMaskLo(origOp.getUpdateBarriers());

    uint8_t barrier_group = 0;
    uint8_t barrier_mask = 0;

    std::tie(barrier_group, barrier_mask) = ELF::reduceWaitMaskTo8bit(waitMaskLo);

    auto regActKernelInvoDescriptorAttr =
            vpux::VPURegMapped::getRegMappedAttributeWithValues<vpux::NPUReg40XX::RegMapped_VpuActKernelInvocationType>(
                    rewriter, {{"range", {{"range", kernelRangeTileMask}}},
                               {"barriers_wait_mask_hi_act", {{"barriers_wait_mask_hi_act", waitMaskHi}}},
                               {"barriers_wait_mask_lo_act", {{"barriers_wait_mask_lo_act", waitMaskLo}}},
                               {"barriers_post_mask_hi_act", {{"barriers_post_mask_hi_act", postMaskHi}}},
                               {"barriers_post_mask_lo_act", {{"barriers_post_mask_lo_act", postMaskLo}}},
                               {"barriers_group_mask_act", {{"group_act", barrier_group}, {"mask_act", barrier_mask}}},
                               {"act_invo_barriers_sched",
                                {{"start_after_", origOp.getStartAfter()}, {"clean_after_", origOp.getCleanAfter()}}},
                               {"invo_tile", {{"invo_tile", origOp.getTile()}}},
                               {"kernel_range_index", {{"kernel_range_index", kernelRangeIndex}}},
                               {"perf_packet_out", {{"perf_packet_out", perfPacketTileMask}}}});

    rewriter.create<NPUReg40XX::ActKernelInvocationOp>(origOp->getLoc(), origOp.getSymNameAttr(),
                                                       regActKernelInvoDescriptorAttr, origOp.getTaskLocationAttr(),
                                                       origOp.getKernelRangeAttr(), origOp.getKernelDataAttr(),
                                                       origOp.getKernelParamsAttr(), origOp.getProfilingDataAttr());

    rewriter.eraseOp(origOp);

    return mlir::success();
}

//
// ConvertVPUASM2NPUReg40XXRelocsPass
//

class ConvertVPUASM2NPUReg40XXRelocsPass final :
        public ConvertVPUASM2NPUReg40XXRelocsBase<ConvertVPUASM2NPUReg40XXRelocsPass> {
public:
    explicit ConvertVPUASM2NPUReg40XXRelocsPass(Logger log) {
        Base::initLogger(log, Base::getArgumentName());
    }

    explicit ConvertVPUASM2NPUReg40XXRelocsPass(Logger log, bool enableWLM) {
        Base::initLogger(log, Base::getArgumentName());
        _enableWLM = enableWLM;
    }

    mlir::LogicalResult initialize(mlir::MLIRContext* ctx) final;

private:
    void safeRunOnModule() final;
    bool _enableWLM;
};

mlir::LogicalResult ConvertVPUASM2NPUReg40XXRelocsPass::initialize(mlir::MLIRContext* ctx) {
    if (mlir::failed(Base::initialize(ctx))) {
        return mlir::failure();
    }

    if (wlmEnabled.hasValue()) {
        _enableWLM = wlmEnabled.getValue();
    }

    return mlir::success();
}

void ConvertVPUASM2NPUReg40XXRelocsPass::safeRunOnModule() {
    auto moduleOp = getOperation();
    auto& ctx = getContext();
    mlir::func::FuncOp netFunc;
    IE::CNNNetworkOp cnnOp;

    IE::CNNNetworkOp::getFromModule(moduleOp, cnnOp, netFunc);

    mlir::ConversionTarget target(ctx);

    target.addLegalDialect<NPUReg40XX::NPUReg40XXDialect>();
    target.addLegalDialect<VPUASM::VPUASMDialect>();

    auto mainOps = to_small_vector(netFunc.getOps<ELF::MainOp>());
    VPUX_THROW_UNLESS(mainOps.size() == 1, "Expected exactly one ELF mainOp. Got {0}", mainOps.size());
    auto elfMain = mainOps[0];

    ELF::SymbolReferenceMap symRefMap(elfMain, true);

    mlir::RewritePatternSet patternNNDMA(&ctx);
    patternNNDMA.add<NNDMARewriter>(&ctx, _log, symRefMap);
    target.addIllegalOp<VPUASM::NNDMAOp>();
    if (mlir::failed(mlir::applyPartialConversion(netFunc, target, std::move(patternNNDMA)))) {
        signalPassFailure();
    }

    mlir::RewritePatternSet patterns(&ctx);
    patterns.add<M2IRewriter>(&ctx, _log, symRefMap);
    patterns.add<ActShaveRtRewriter>(&ctx, _log);
    patterns.add<ActKernelInvocationRewriter>(&ctx, _log, symRefMap);
    patterns.add<ActKernelRangeRewriter>(&ctx, _log, symRefMap);
    target.addIllegalOp<VPUASM::M2IOp>();
    target.addIllegalOp<VPUASM::ActShaveRtOp>();
    target.addIllegalOp<VPUASM::ActKernelInvocationOp>();
    target.addIllegalOp<VPUASM::ActKernelRangeOp>();
    if (mlir::failed(mlir::applyPartialConversion(netFunc, target, std::move(patterns)))) {
        signalPassFailure();
    }
}

}  // namespace

//
// createConvertVPUASM2NPUReg40XXRelocsPass
//

std::unique_ptr<mlir::Pass> vpux::createConvertVPUASM2NPUReg40XXRelocsPass(Logger log, bool enableWLM) {
    return std::make_unique<ConvertVPUASM2NPUReg40XXRelocsPass>(log, enableWLM);
}
